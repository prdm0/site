---
title: "S√©rie de Taylor, c√≥digo espaguete e outras coisas"
author: "Prof. Pedro Rafael D. Marinho"
date: "2022-10-06"
categories: [news, code, R]
bibliography: references.bib
---

![](taylor.gif)

Uma boa forma de desenvolver flu√™ncia em uma linguagem de programa√ß√£o √© se submeter a resolver problemas utilizando a linguagem que voc√™ deseja aprender. Para quem tem interesse em trabalhar com computa√ß√£o cient√≠fica, um exerc√≠cio muito interessante √© selecionar alguns problemas b√°sicos na sua √°rea de atua√ß√£o e tentar resolver! Tente entender bem o problema a ser resolvido e se submeta ao exerc√≠cio de implementar uma fun√ß√£o da forma mais gen√©rica poss√≠vel.

Esse t√≥pico sugiro meio que por acaso. Na verdade, eu estava na sala de aula, explicando aos meus alunos sobre [funcionais em R](https://adv-r.hadley.nz/functionals.html) e dizia a eles que **nem sempre** precisamos utilizar instru√ß√µes de repeti√ß√£o como `for`, `while` e `repeat` para repetir trechos de c√≥digos, e na aula usei o exemplo das [s√©ries de Taylor](https://pt.wikipedia.org/wiki/S%C3%A9rie_de_Taylor). Tanto na aula, quanto aqui, deixo claro que s√©ries de Taylor n√£o √© o tema principal, muito embora o t√≠tulo da postagem possa talvez te confundir a respeito do prop√≥sito dessa postagem.

O maior objetivo √© fazer com que voc√™ possa estudar o c√≥digo e entender os recursos utilizados para se chegar a solu√ß√£o. Procure entender o papel do funcional `sapply()`, da fun√ß√£o `do.call()`, do operador dot-dot-dot `...` e do uso de fun√ß√£o an√¥nima no funcional `sapply()`. Esses s√£o basicamente os principais pontos do c√≥digo.

Todavia, √© claro que eu terei que definir brevemente o que √© uma s√©rie de Taylor. Afinal, precisamos compreender, de forma clara, o que o c√≥digo tenta implementar. Tudo bem?! ü§ù

Compreender de forma cristalina o problema √© a chave üîê para desenvolver, de forma consistente, um c√≥digo coerente e reaproveit√°vel. Tente evitar o c√≥digo espaguete, em que voc√™ at√© resolve o problema, por√©m, o reaproveitamento de c√≥digo e a manuten√ß√£o do mesmo se torna muito desafiador! Fuja desses tipos de implementa√ß√µes e projetos, pois estes n√£o acrescentam muito no seu aprendizado de programa√ß√£o.

::: callout-tip
## Fuja de c√≥digos espaguetes üçù

Atualmente, o meu maior pavor üò± em ajudar algu√©m em programa√ß√£o √© olhar para o c√≥digo de uma pessoa e ver nele um espaguete com instru√ß√µes confusas e escritas de forma "enlinhada" (como um espaguete üçù) e cheios de gambiarras (p√©ssimas pr√°ticas de programa√ß√£o) üò•.

Evite muitas condi√ß√µes aninhadas para n√£o cair em uma pir√¢mide de destrui√ß√£o e acabe construindo c√≥digo espaguete. Abuse, **na medida do poss√≠vel**, do uso de funcionais em R.

Eu ministrei uma palestra no [Workshop Paraibano de Estat√≠stica](https://sites.google.com/view/workshopparaibano/palestrantes?authuser=0), em 2020, intitulada **Uso de funcionais em R: evitando loops e seus benef√≠cios** e alerto um pouco sobre a necessidade de construirmos c√≥digos que possam ser reutiliz√°veis e mais f√°ceis de manter.

Caso deseje ver:

1.  Para acessar o v√≠deo da apresenta√ß√£o, clique [aqui](https://www.youtube.com/watch?v=rqjII_sA6V8) üìΩÔ∏è;

2.  Para ter acesso aos slides utilizados, clique [aqui](https://prdm0.github.io/palestra_wpbest_2020/#1) üìñ.

Se aproximar do uso de funcionais, quando poss√≠vel, √© um √≥timo come√ßo para evitar c√≥digo espaguete. üéâ
:::

![N√£o codifique como um chefe üë®‚Äçüç≥ italiano! Macarronada s√≥ √© saborosa no seu prato! üòã](pasta_00.png){fig-align="left" width="350"}

::: {layout="[25,-2,10]"}
![Quando termino de ajudar](pasta_face.gif){width="30%"}
![Quando algu√©m me pede ajuda e me apresenta um c√≥digo bagun√ßado. üò∂](desconfiado.gif){width="40%"} 
:::

Uma √≥tima postagem que encontrei na internet e que poder√° ser √∫til para voc√™ entender sobre a import√¢ncia de se afastar de c√≥digo espaguete, em R, poder√° ser acessada clicando [**AQUI**](https://towardsdatascience.com/cleaner-r-code-with-functional-programming-adc37931ef7a). E n√£o se engane, apesar do termo engra√ßado (c√≥digo espaguete), h√° diversos livros na computa√ß√£o sobre o tema.

## S√©rie de Taylor

Em matem√°tica, uma s√©rie de Taylor √© uma soma de fun√ß√µes, de tal forma que

$$f(x) = \sum_{n = 0}^{\infty} a_n(x-a)^n,$$ com

$$a_n = \frac{f^{(n)}(a)}{n!},$$ em que $f^{(n)}(a)$ √© a $n$-√©sima derivada da fun√ß√£o $f$ (supostamente sendo infinitamente diferenci√°vel) avaliada no ponto $a$. Para o caso de $a = 0$, essa aproxima√ß√£o √© denominada de s√©rie de Maclaurin.

Por exemplo, considerado $a = 0$, poderemos aproximar $f(x) = e^x$, em torno de $a = 0$ por meio da express√£o abaixo:

$$e^x \approx \sum_{n = 0}^N \frac{x^n}{n!},$$ com $N < \infty$.

```{r}
#| echo: false
#| warning: false
#| fig-cap: "Note que temos uma √≥tima aproxima√ß√£o de $f(x)$, em torno de $a = 0$, por meio do polin√¥mio de Taylor, considerando $N = 2$."
library(ggplot2)
library(purrr)
library(glue)

# S√©rie de Taylor ---------------------------------------------------------
taylor <- function(n = 1L, func, x, a = 0,...){
  an <- function(n, ...){
    Deriv::Deriv(f = func, nderiv = n, ...)
  }
  
  if(n == 1L)
    return(func(a))
  
  sapply(
    X = 1L:n,
    FUN = \(n, x) do.call(an(n, ...), list(x = x))/factorial(n) * (x - a)^n,
    x = x
  ) |> sum() + func(a) 
}

plot_taylor <- function(n = 1L, func, x, a, lower = -1, upper = 1, ...){
  x <- seq(lower, upper, length.out = 100L)
  y <- func(x)
  
  y_taylor <- 
    sapply(
      X = x,
      FUN = \(x) taylor(n = n, func = func, x = x, a = a, ...)
    )
  
  data.frame(
    x = c(x, x), 
    y = c(y, y_taylor),
    classe = c(rep("f(x)", 100L), rep("Taylor", 100L))
  ) |> 
    ggplot() +
    geom_line(aes(x = x, y = y, color = classe), size = 0.9) +
    geom_point(x = a, y = func(a), color = "blue", size = 2) +
    ggtitle(
      label = "S√©rie de Taylor", 
      subtitle = glue("Aproxima√ß√£o de uma fun√ß√£o f(x), com n = {n}") 
    ) +
    ylab("f(x)") +
    scale_color_manual(values = c("black", "tomato")) + 
    theme(
      text = element_text(face = "bold")
    ) + 
    labs(color = "") 
}

plot_taylor(n = 2L, func = \(x) exp(x), lower = -1, upper = 1, a = 0)
```

## Implementa√ß√£o

N√£o irei discutir, nos por menores, a implementa√ß√£o do c√≥digo, pois certamente seria enfadonho. Estudar o c√≥digo "n√£o espaguete" üçù de outra pessoa √© uma boa forma de adquirir conhecimento. O GitHub est√° a√≠ para voc√™ estudar um universo de c√≥digos e melhorar suas pr√°ticas de programa√ß√£o, seja em R ou qualquer outra linguagem de programa√ß√£o.

O que eu basicamente fiz foi implementar duas fun√ß√µes:

1.  A fun√ß√£o `taylor(n = 1L, func, x, a = 0,...)` que recebe o n√∫mero de somas `n`, a fun√ß√£o `func` a ser aproximada, um valor `x` e o valor de `a`. Tamb√©m √© poss√≠vel passar argumentos adicionais usando o operador **varargs** dot-dot-dot (`...`), em que voc√™ poder√° controlar argumentos da fun√ß√£o `Deriv()` do pacote [**Deriv**](https://github.com/sgsokol/Deriv) utilizado para o c√°lculo das derivadas simb√≥licas de $f(x)$. O pacote encontra-se no *Comprehensive R Archive Network* - CRAN e poder√° ser instalado fazendo `install.packages("Deriv")`[@Deriv];

2.  A fun√ß√£o `plot_taylor(n, func, lower, upper, a)` que permitir√° que possamos visualizar graficamente a aproxima√ß√£o. Temos que `n` √© a quantidade de somas utilizadas na aproxima√ß√£o, `func` √© a fun√ß√£o que desejamos aproximar, `lower` √© o limite inferior do eixo x, `upper` √© o limite superior do eixo $x$ e `a` √© o ponto onde tentaremos uma boa aproxima√ß√£o em seu entorno.

Note que, em R, fun√ß√µes s√£o objetos de primeira classe. Isso quer dizer que, podemos criar uma fun√ß√£o dentro de outra fun√ß√£o e, sobretudo, poderemos ter uma fun√ß√£o retornando uma fun√ß√£o, como √© o caso da fun√ß√£o `an()` definida em `taylor()`. Note que a fun√ß√£o `an()` retorna a fun√ß√£o que implementa a derivada de `func`.

```{r}
#| code-line-numbers: true
# S√©rie de Taylor ---------------------------------------------------------
taylor <- function(n = 1L, func, x, a = 0,...){
  an <- function(n, ...){
    Deriv::Deriv(f = func, nderiv = n, ...)
  }
  
  if(n == 1L)
    return(func(a))
  
  sapply(
    X = 1L:n,
    FUN = \(n, x) do.call(an(n, ...), list(x = x))/factorial(n) * (x - a)^n,
    x = x
  ) |> sum() + func(a) 
}

# Testando a fun√ß√£o taylor(). 
taylor(n = 2L, func = \(x) x^2, x = 0.5, a = 0)
```

::: callout-tip
## Derivadas simb√≥licas

Conhecer derivadas de fun√ß√µes √© algo muito corriqueiro na computa√ß√£o cient√≠fica. Com o pacote [Deriv](https://CRAN.R-project.org/package=Deriv) voc√™ n√£o precisa se preocupar em derivar simbolicamente (analiticamente) as $n$-√©simas derivadas de uma fun√ß√£o.

```{r}
library(Deriv)

# Derivando simbolicamente log(1-sin(x)). Perceba que
#  o retorno √© uma fun√ß√£o R em termos de x.
Deriv(f = \(x) log(1-sin(x)))
```

√â importante destacar que a obten√ß√£o de derivadas simb√≥licas s√£o mais custosas que os m√©todos num√©ricos de deriva√ß√£o, sobretudo quando temos interesse de obter ordens elevadas de deriva√ß√£o. Mesmo assim, irei utilizar aqui a biblioteca [Deriv](https://CRAN.R-project.org/package=Deriv), que poder√° ser bastante √∫til em diversas situa√ß√µes. Para a obten√ß√£o de derivadas num√©ricas, estude a biblioteca [numDeriv](https://CRAN.R-project.org/package=numDeriv) [@numDeriv].
:::

Visualizar graficamente os resultados de uma fun√ß√£o poder√° nos ajudar na valida√ß√£o da implementa√ß√£o. Comportamentos inadequados na fun√ß√£o `taylor()` seriam facilmente percebidos ao utilizar a fun√ß√£o `plot_taylor()`.

```{r}
#| code-line-numbers: true
library(ggplot2)
library(glue)
library(patchwork)

plot_taylor <- function(n = 1L, func, a, lower = -1, upper = 1, ...){
  x <- seq(lower, upper, length.out = 100L)
  y <- func(x)
  
  y_taylor <- 
    sapply(
      X = x,
      FUN = \(x) taylor(n = n, func = func, x = x, a = a, ...)
    )
  
  data.frame(
    x = c(x, x), 
    y = c(y, y_taylor),
    classe = c(rep("f(x)", 100L), rep("Taylor", 100L))
  ) |> 
    ggplot() +
    geom_line(aes(x = x, y = y, color = classe), size = 0.9) +
    geom_point(x = a, y = func(a), color = "blue", size = 2) +
    ggtitle(
      label = "S√©rie de Taylor", 
      subtitle = glue("Aproxima√ß√£o de uma fun√ß√£o f(x)\n n = {n}") 
    ) +
    ylab("f(x)") +
    scale_color_manual(values = c("black", "tomato")) + 
    theme(
      text = element_text(face = "bold")
    ) + 
    labs(color = "") 
}

# Aproximando func em torno de "a" ----------------------------------------
p1 <- plot_taylor(
  n = 3,
  func = \(x) exp(x),
  lower = -1,
  upper = 1,
  a = 0.5
)

p2 <- plot_taylor(
  n = 3,
  func = \(x) x^3,
  lower = -1,
  upper = 1,
  a = 0.5
)

p3 <- plot_taylor(
  n = 3,
  func = \(x) 3*x^3 + 4*x^2,
  lower = -1,
  upper = 1,
  a = 0
)

p4 <- plot_taylor(
  n = 3,
  func = \(x) 15*x^2 - 14*x + 7,
  lower = -0.8,
  upper = 2,
  a = 1.5
)

(p1 + p2)/(p3 + p4) + plot_annotation(tag_levels = "I")
```

## Refer√™ncias
