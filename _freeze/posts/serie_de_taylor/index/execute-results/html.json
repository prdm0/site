{
  "hash": "36d773ff0e2913b7c57a311bf9812a63",
  "result": {
    "markdown": "---\ntitle: \"S√©rie de Taylor, c√≥digo espaguete e outras coisas\"\nauthor: \"Prof. Pedro Rafael D. Marinho\"\ndate: \"2022-10-06\"\ncategories: [news, code, R]\nbibliography: references.bib\n---\n\n\n![](taylor.gif)\n\nUma boa forma de desenvolver flu√™ncia em uma linguagem de programa√ß√£o √© se submeter a resolver problemas utilizando a linguagem que voc√™ deseja aprender. Para quem tem interesse em trabalhar com computa√ß√£o cient√≠fica, um exerc√≠cio muito interessante √© selecionar alguns problemas b√°sicos na sua √°rea de atua√ß√£o e tentar resolver! Tente entender bem o problema a ser resolvido e se submeta ao exerc√≠cio de implementar uma fun√ß√£o da forma mais gen√©rica poss√≠vel.\n\nEsse t√≥pico sugiro meio que por acaso. Na verdade, eu estava na sala de aula, explicando aos meus alunos sobre [funcionais em R](https://adv-r.hadley.nz/functionals.html) e dizia a eles que **nem sempre** precisamos utilizar instru√ß√µes de repeti√ß√£o como `for`, `while` e `repeat` para repetir trechos de c√≥digos, e na aula usei o exemplo das [s√©ries de Taylor](https://pt.wikipedia.org/wiki/S%C3%A9rie_de_Taylor). Tanto na aula, quanto aqui, deixo claro que s√©ries de Taylor n√£o √© o tema principal, muito embora o t√≠tulo da postagem possa talvez te confundir a respeito do prop√≥sito dessa postagem.\n\nO maior objetivo √© fazer com que voc√™ possa estudar o c√≥digo e entender os recursos utilizados para se chegar a solu√ß√£o. Procure entender o papel do funcional `sapply()`, da fun√ß√£o `do.call()`, do operador dot-dot-dot `...` e do uso de fun√ß√£o an√¥nima no funcional `sapply()`. Esses s√£o basicamente os principais pontos do c√≥digo.\n\nTodavia, √© claro que eu terei que definir brevemente o que √© uma s√©rie de Taylor. Afinal, precisamos compreender, de forma clara, o que o c√≥digo tenta implementar. Tudo bem?! ü§ù\n\nCompreender de forma cristalina o problema √© a chave üîê para desenvolver, de forma consistente, um c√≥digo coerente e reaproveit√°vel. Tente evitar o c√≥digo espaguete, em que voc√™ at√© resolve o problema, por√©m, o reaproveitamento de c√≥digo e a manuten√ß√£o do mesmo se torna muito desafiador! Fuja desses tipos de implementa√ß√µes e projetos, pois estes n√£o acrescentam muito no seu aprendizado de programa√ß√£o.\n\n::: callout-tip\n## Fuja de c√≥digos espaguetes üçù\n\nAtualmente, o meu maior pavor üò± em ajudar algu√©m em programa√ß√£o √© olhar para o c√≥digo de uma pessoa e ver nele um espaguete com instru√ß√µes confusas e escritas de forma \"enlinhada\" (como um espaguete üçù) e cheios de gambiarras (p√©ssimas pr√°ticas de programa√ß√£o) üò•.\n\nEvite muitas condi√ß√µes aninhadas para n√£o cair em uma pir√¢mide de destrui√ß√£o e acabe construindo c√≥digo espaguete. Abuse, **na medida do poss√≠vel**, do uso de funcionais em R.\n\nEu ministrei uma palestra no [Workshop Paraibano de Estat√≠stica](https://sites.google.com/view/workshopparaibano/palestrantes?authuser=0), em 2020, intitulada **Uso de funcionais em R: evitando loops e seus benef√≠cios** e alerto um pouco sobre a necessidade de construirmos c√≥digos que possam ser reutiliz√°veis e mais f√°ceis de manter.\n\nCaso deseje ver:\n\n1.  Para acessar o v√≠deo da apresenta√ß√£o, clique [aqui](https://www.youtube.com/watch?v=rqjII_sA6V8) üìΩÔ∏è;\n\n2.  Para ter acesso aos slides utilizados, clique [aqui](https://prdm0.github.io/palestra_wpbest_2020/#1) üìñ.\n\nSe aproximar do uso de funcionais, quando poss√≠vel, √© um √≥timo come√ßo para evitar c√≥digo espaguete. üéâ\n:::\n\n![N√£o codifique como um chefe üë®‚Äçüç≥ italiano! Macarronada s√≥ √© saborosa no seu prato! üòã](pasta_00.png){fig-align=\"left\" width=\"350\"}\n\n::: {layout=\"[25,-2,10]\"}\n![Quando termino de ajudar](pasta_face.gif){width=\"30%\"}\n![Quando algu√©m me pede ajuda e me apresenta um c√≥digo bagun√ßado. üò∂](desconfiado.gif){width=\"40%\"} \n:::\n\nUma √≥tima postagem que encontrei na internet e que poder√° ser √∫til para voc√™ entender sobre a import√¢ncia de se afastar de c√≥digo espaguete, em R, poder√° ser acessada clicando [**AQUI**](https://towardsdatascience.com/cleaner-r-code-with-functional-programming-adc37931ef7a). E n√£o se engane, apesar do termo engra√ßado (c√≥digo espaguete), h√° diversos livros na computa√ß√£o sobre o tema.\n\n## S√©rie de Taylor\n\nEm matem√°tica, uma s√©rie de Taylor √© uma soma de fun√ß√µes, de tal forma que\n\n$$f(x) = \\sum_{n = 0}^{\\infty} a_n(x-a)^n,$$ com\n\n$$a_n = \\frac{f^{(n)}(a)}{n!},$$ em que $f^{(n)}(a)$ √© a $n$-√©sima derivada da fun√ß√£o $f$ (supostamente sendo infinitamente diferenci√°vel) avaliada no ponto $a$. Para o caso de $a = 0$, essa aproxima√ß√£o √© denominada de s√©rie de Maclaurin.\n\nPor exemplo, considerado $a = 0$, poderemos aproximar $f(x) = e^x$, em torno de $a = 0$ por meio da express√£o abaixo:\n\n$$e^x \\approx \\sum_{n = 0}^N \\frac{x^n}{n!},$$ com $N < \\infty$.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Note que temos uma √≥tima aproxima√ß√£o de $f(x)$, em torno de $a = 0$, por meio do polin√¥mio de Taylor, considerando $N = 2$.](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n## Implementa√ß√£o\n\nN√£o irei discutir, nos por menores, a implementa√ß√£o do c√≥digo, pois certamente seria enfadonho. Estudar o c√≥digo \"n√£o espaguete\" üçù de outra pessoa √© uma boa forma de adquirir conhecimento. O GitHub est√° a√≠ para voc√™ estudar um universo de c√≥digos e melhorar suas pr√°ticas de programa√ß√£o, seja em R ou qualquer outra linguagem de programa√ß√£o.\n\nO que eu basicamente fiz foi implementar duas fun√ß√µes:\n\n1.  A fun√ß√£o `taylor(n = 1L, func, x, a = 0,...)` que recebe o n√∫mero de somas `n`, a fun√ß√£o `func` a ser aproximada, um valor `x` e o valor de `a`. Tamb√©m √© poss√≠vel passar argumentos adicionais usando o operador **varargs** dot-dot-dot (`...`), em que voc√™ poder√° controlar argumentos da fun√ß√£o `Deriv()` do pacote [**Deriv**](https://github.com/sgsokol/Deriv) utilizado para o c√°lculo das derivadas simb√≥licas de $f(x)$. O pacote encontra-se no *Comprehensive R Archive Network* - CRAN e poder√° ser instalado fazendo `install.packages(\"Deriv\")`[@Deriv];\n\n2.  A fun√ß√£o `plot_taylor(n, func, lower, upper, a)` que permitir√° que possamos visualizar graficamente a aproxima√ß√£o. Temos que `n` √© a quantidade de somas utilizadas na aproxima√ß√£o, `func` √© a fun√ß√£o que desejamos aproximar, `lower` √© o limite inferior do eixo x, `upper` √© o limite superior do eixo $x$ e `a` √© o ponto onde tentaremos uma boa aproxima√ß√£o em seu entorno.\n\nNote que, em R, fun√ß√µes s√£o objetos de primeira classe. Isso quer dizer que, podemos criar uma fun√ß√£o dentro de outra fun√ß√£o e, sobretudo, poderemos ter uma fun√ß√£o retornando uma fun√ß√£o, como √© o caso da fun√ß√£o `an()` definida em `taylor()`. Note que a fun√ß√£o `an()` retorna a fun√ß√£o que implementa a derivada de `func`.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"true\"}\n# S√©rie de Taylor ---------------------------------------------------------\ntaylor <- function(n = 1L, func, x, a = 0,...){\n  an <- function(n, ...){\n    Deriv::Deriv(f = func, nderiv = n, ...)\n  }\n  \n  if(n == 1L)\n    return(func(a))\n  \n  sapply(\n    X = 1L:n,\n    FUN = \\(n, x) do.call(an(n, ...), list(x = x))/factorial(n) * (x - a)^n,\n    x = x\n  ) |> sum() + func(a) \n}\n\n# Testando a fun√ß√£o taylor(). \ntaylor(n = 2L, func = \\(x) x^2, x = 0.5, a = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.75\n```\n:::\n:::\n\n\n::: callout-tip\n## Derivadas simb√≥licas\n\nConhecer derivadas de fun√ß√µes √© algo muito corriqueiro na computa√ß√£o cient√≠fica. Com o pacote [Deriv](https://CRAN.R-project.org/package=Deriv) voc√™ n√£o precisa se preocupar em derivar simbolicamente (analiticamente) as $n$-√©simas derivadas de uma fun√ß√£o.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Deriv)\n\n# Derivando simbolicamente log(1-sin(x)). Perceba que\n#  o retorno √© uma fun√ß√£o R em termos de x.\nDeriv(f = \\(x) log(1-sin(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x) \n-(cos(x)/(1 - sin(x)))\n```\n:::\n:::\n\n\n√â importante destacar que a obten√ß√£o de derivadas simb√≥licas s√£o mais custosas que os m√©todos num√©ricos de deriva√ß√£o, sobretudo quando temos interesse de obter ordens elevadas de deriva√ß√£o. Mesmo assim, irei utilizar aqui a biblioteca [Deriv](https://CRAN.R-project.org/package=Deriv), que poder√° ser bastante √∫til em diversas situa√ß√µes. Para a obten√ß√£o de derivadas num√©ricas, estude a biblioteca [numDeriv](https://CRAN.R-project.org/package=numDeriv) [@numDeriv].\n:::\n\nVisualizar graficamente os resultados de uma fun√ß√£o poder√° nos ajudar na valida√ß√£o da implementa√ß√£o. Comportamentos inadequados na fun√ß√£o `taylor()` seriam facilmente percebidos ao utilizar a fun√ß√£o `plot_taylor()`.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"true\"}\nlibrary(ggplot2)\nlibrary(glue)\nlibrary(patchwork)\n\nplot_taylor <- function(n = 1L, func, a, lower = -1, upper = 1, ...){\n  x <- seq(lower, upper, length.out = 100L)\n  y <- func(x)\n  \n  y_taylor <- \n    sapply(\n      X = x,\n      FUN = \\(x) taylor(n = n, func = func, x = x, a = a, ...)\n    )\n  \n  data.frame(\n    x = c(x, x), \n    y = c(y, y_taylor),\n    classe = c(rep(\"f(x)\", 100L), rep(\"Taylor\", 100L))\n  ) |> \n    ggplot() +\n    geom_line(aes(x = x, y = y, color = classe), size = 0.9) +\n    geom_point(x = a, y = func(a), color = \"blue\", size = 2) +\n    ggtitle(\n      label = \"S√©rie de Taylor\", \n      subtitle = glue(\"Aproxima√ß√£o de uma fun√ß√£o f(x)\\n n = {n}\") \n    ) +\n    ylab(\"f(x)\") +\n    scale_color_manual(values = c(\"black\", \"tomato\")) + \n    theme(\n      text = element_text(face = \"bold\")\n    ) + \n    labs(color = \"\") \n}\n\n# Aproximando func em torno de \"a\" ----------------------------------------\np1 <- plot_taylor(\n  n = 3,\n  func = \\(x) exp(x),\n  lower = -1,\n  upper = 1,\n  a = 0.5\n)\n\np2 <- plot_taylor(\n  n = 3,\n  func = \\(x) x^3,\n  lower = -1,\n  upper = 1,\n  a = 0.5\n)\n\np3 <- plot_taylor(\n  n = 3,\n  func = \\(x) 3*x^3 + 4*x^2,\n  lower = -1,\n  upper = 1,\n  a = 0\n)\n\np4 <- plot_taylor(\n  n = 3,\n  func = \\(x) 15*x^2 - 14*x + 7,\n  lower = -0.8,\n  upper = 2,\n  a = 1.5\n)\n\n(p1 + p2)/(p3 + p4) + plot_annotation(tag_levels = \"I\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n## Refer√™ncias\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}